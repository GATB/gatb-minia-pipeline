#!/usr/bin/env python

import sys, os
from subprocess import call, Popen, PIPE
import glob
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) #unbuffered print, solves badly ordered stdout on clusters
import multiprocessing
nb_cpus = multiprocessing.cpu_count()

prefix="assembly"

doc = """GATB Pipeline

Usage:
    %s [arguments]

Reads (mandatory, specify at least one of these parameters):
    -p interleaved_paired_reads     interleaved FASTA or FASTQ paired reads
    -p left_mates right_mates       two FASTA or FASTQ paired reads (non-interleaved)
    -u unpaired_reads               unpaired FASTA or FASTQ reads
    -l list_of_unpaired_reads       one file name per line
    -m interleaved_mate_pairs       same input as paired reads (-p) but for mate pairs
    -m left_mates right_mates       same input as paired reads (-p) but for mate pairs

Advanced parameters (optional):
    -o prefix                       prefix of the output files (default: assembly)
    -c contigs_file                 only perform scaffolding+gapfilling from these contigs
    -k kmer_size                    use this k-mer size (skips kmergenie if -k, -t and -g are specified)
    -t min_abundance                use this minimum abundance value
    -g genome_size                  adjust memory usage with respect to this genome size
    --multik                        multi-k mode (experimental, not currently supported)
""" % (sys.argv[0])

paired_reads = []
mate_pairs = []
unpaired_reads = []
contigs = None
genome_size = 0
k = 0
min_abundance = 0
multi_k_mode = False 

#scaffolding_method="superscaffolder"
#scaffolding_method="sspace"
scaffolding_method="besst"

try:
    skip = 1 # to handle paired-end case (-p XX XX)
    for i,arg in enumerate(sys.argv):
        if skip > 0:
            skip -= 1
            continue
        skip = 1
        if arg == "-p" or arg == "-m":
           if i+2 >= len(sys.argv) or sys.argv[i+2][0] == "-":
               # interleaved case
               library = sys.argv[i+1]
               has_space = ' ' in sys.argv[i+1]
           else:
               # non-interleaved case
               library = sys.argv[i+1] + " " + sys.argv[i+2]
               skip = 2
               has_space = ' ' in sys.argv[i+1] or ' ' in sys.argv[i+2]
           if has_space:
               print("Space character isn't allowed in file names")
               exit(0)
           paired_reads.append(library)
           if arg == "-m":
               mate_pairs.append(library)
        elif arg == "-u":
           unpaired_reads.append(sys.argv[i+1])
        elif arg == "-c":
           contigs = sys.argv[i+1]
        elif arg == "-k":
           k = int(sys.argv[i+1])
        elif arg == "-t":
           min_abundance = int(sys.argv[i+1])
        elif arg == "-g":
           genome_size = int(sys.argv[i+1])
        elif arg == "-l":
            unpaired_reads = open(sys.argv[i+1]).read().splitlines()
        elif arg == "-o":
            prefix = sys.argv[i+1]

        # special cases: 0-parameters arguments, need for "skip=0", well one day i'll use getopt
        elif arg == "--multik":
           multi_k_mode = True
           skip = 0
        elif arg == "--sspace":  #hidden parameter, for now
            scaffolding_method = "sspace" 
            skip = 0
        elif arg in ["-h", "-help", "--help"]:
            raise Exception("Displaying help") 
        else:
            print("Unknown parameters", arg)
    if len(paired_reads) + len(unpaired_reads) == 0:
        raise Exception("Please input at least one read dataset") 
except:
    import traceback
    traceback.print_exc()
    print doc
    sys.exit(1)

if k != 0 and (min_abundance == 0 or genome_size == 0):
    sys.exit("If you specify k, please specify min_abundance and genome_size as well")


DIR = os.path.dirname(os.path.realpath(__file__))

def execute(program, cmdline=[], interpreter=None, stdout=None, memused=False):
    ret = 0
    try:
        cmd = []
        if memused:
            cmd += [ "%s/tools/memused" % DIR ]
        if interpreter:
            cmd += [interpreter]
        if program is not None:
            cmd += [ "%s/%s" % (DIR, program) ] 
        cmd += map(str, cmdline)
        program_string = ((interpreter + " ") if interpreter is not None else "") + (program if program is not None else "")
        print >>sys.stderr, "Execution of '%s'. Command line: \n     %s" % (program_string, ' '.join(cmd))
        ret = call(cmd, stdout=stdout)
    except OSError as e:
        print >>sys.stderr, "Exception:",e
        ret = 1
    if ret:
        print >>sys.stderr, "Execution of '%s' failed. Command line: \n     %s" % (program_string, ' '.join(cmd))
        exit(1)

list_reads = prefix + ".list_reads"

def create_list_reads(extra_reads = []):
    # create of flat text file with all reads
    with open(list_reads,"w") as f:
        for read in paired_reads + unpaired_reads + extra_reads:
            for filename in read.strip().split():
                if not os.path.exists(filename):
                    exit("Read file %s does not exist" % filename)
                f.write(filename + "\n")

# ------------------------------
# kmergenie

from kmergenie.wrapper import kmergenie
from kmergenie.wrapper import parse_kmergenie_results 
from kmergenie.wrapper import all_k_values_fitted_or_not

# ------------------------------
# minia

def minia(k, min_abundance, prefix):
    global genome_size
    global contigs
    if k == 0:
        exit('cannot run minia with k=0 (did kmergenie fail to detect best k?)')
    print "compiling minia to support k=%d" % k

    call("make -j8 k=%d -C %s/minia/" % (k, DIR), shell=True)

    genome_size = max(1000000000, genome_size) #hack to make it use at least 1GB of memory to go faster on bacterial genomes
    execute('minia/minia', [list_reads, k, min_abundance, genome_size, prefix], memused=True)
    contigs = prefix + ".contigs.fa"
    return contigs

# ------------------------------
# superscaffolder

def superscaffolder(contigs,library,output_filename=""):
    execute("superscaffolder/superscaffolding.py", [contigs, library, "-o", output_filename], interpreter="python", memused=True)

#-------------------------------
# sspace wrapper

def get_paired_end_parameters(contigs, library, is_mate_pairs = False):
    paired_reads = library.split(' ')
    cmd = ["%s/tools/estimate-insert-sizes" % DIR, contigs] + paired_reads
    if is_mate_pairs:
        cmd += ["--RF"] # force mate pairs
    output = Popen(cmd, stdout=PIPE).communicate()[0]
    orientation, mean, stdev = None, None, None
    for line in output.split('\n'):
        if line.startswith('Orientation'):
            l = line.split()
            orientation, mean, stdev = l[1], int(l[3]), int(l[5])
    print "GATB-Pipeline estimated insert size of library", paired_reads, ":", mean, stdev, orientation
    return orientation, mean, stdev
    
def possibly_gunzip(filename, lib_index, paired_index=None):
    if filename.endswith('.gz'):
        unzipped_filename = '.'.join(filename.split(".")[:-1])
        ext = unzipped_filename.split(".")[-1]
        output = prefix + '.lib%d' % lib_index 
        if paired_index:
            output += "_%d" % paired_index
        output += "." + ext
        print "Gunzipping", filename, "to", output
        outfile = open(output, 'wb')
        execute(None, ['-c', filename], interpreter='gunzip', stdout=outfile)
        outfile.close
        return output 
    return filename

def sspace(contigs, paired_reads, output_filename=""):
    # create a sspace config file
    lib_file = prefix + '.sspace.config'
    with open(lib_file, 'w') as f:
        for i, library in enumerate(paired_reads):
            is_mate_pairs = library in mate_pairs
            # sspace needs de-interleaved input
            if ' ' not in library:
                library = possibly_gunzip(library, i)
                print "Splitting interleaved file:", library
                ext = library.split(".")[-1]
                p1, p2 = [prefix + ".lib%d_%d." % (i,j) + ext for j in [1,2] ]
                #de-interleave reads using SGA's script (was too lazy to write my own)
                execute('tools/sga-deinterleave.pl', [library, p1, p2], interpreter="perl")
                library = p1 + " " + p2
            else:
                # sspace basic cannot work with gzipped files
                p1, p2 = library.split(' ')
                library = possibly_gunzip(p1, i, 1) + ' ' + possibly_gunzip(p2, i, 2)

            # estimate insert size
            orientation, mean, stdev = get_paired_end_parameters(contigs, library, is_mate_pairs)
            if orientation is None:
                exit("Error running estimate-insert-sizes for library: %s" % library)

            # sspace error isn't exactly the stdev; subjectively, I'm converting using 3 sigmas
            error = min(max(0.1, stdev * 3.0 / mean),0.9)
            f.write('lib%d %s %d %0.1f %s\n' % (i, library, mean, error, orientation))

    # run sspace
    cmd = ['-l', lib_file, '-s', contigs, '-b', prefix + '.sspace']
    execute('sspace/SSPACE_Basic_v2.0.pl', cmd, interpreter="perl", memused=True)
    print "SSPACE is done! the maximal memory used above was for SSPACE only"

    # clean up intermediate sspace files
    

# ------------------------------
# besst wrapper

def revcomp_matepairs(library, i):
    new_mate_pairs = []
    print "Reverse-complementing mate-pairs for BESST:", " ".join(library)
    for j, mates in enumerate(library):
        ext = mates.split(".")[-1]
        p = prefix + (".lib%d_%d_MPrc." % (i, j+1)) + ext
        #RC using seqtk (was too lazy to write my own), wrapped to handle stdout redirection
        execute('tools/rc.sh', [mates, p])
        new_mate_pairs.append(p)
    return new_mate_pairs

def run_besst_mapping(i, contigs, library):
    # besst needs de-interleaved input
    if ' ' not in library:
        library = possibly_gunzip(library, i) # until sga-deinterleave supports gzipped input, no other choice but to gunzip
        print "Splitting interleaved file:", library
        ext = library.split(".")[-1]
        p1, p2 = [prefix + ".lib%d_%d." % (i,j) + ext for j in [1,2] ]
        #de-interleave reads using SGA's script (was too lazy to write my own)
        execute('tools/sga-deinterleave.pl', [library, p1, p2], interpreter="perl")
        library = p1 + " " + p2
    paired_reads = library.split(' ')

    # BESST needs to reversecomplement all mate pairs
    is_mate_pairs = library in mate_pairs
    if is_mate_pairs:
        paired_reads = revcomp_matepairs(paired_reads, i)
        
    output_bam = prefix + '.lib_%d' % i
    os.environ["TEMP"] = os.getcwd() # besst uses tempfile which uses $TEMP to store mapping data
    # bwa mem produces wrong contamination estimates (see assemblathon dataset)
    execute('BESST/scripts/reads_to_ctg_map.py', ["--nomem","--threads",nb_cpus] + paired_reads + [contigs, output_bam], interpreter="python")
    return output_bam + ".bam"

# besst needs python >= 2.7
def check_for_python_27():
    for i, python27 in enumerate(['python', 'python2.7', 'python-2.7']):
        try:
            ret = call([python27, "-c", "from collections import Counter"])#,stdout=PIPE,stderr=PIPE)
        except:
            ret = 1
        if ret == 0:
            if i > 0:
                print "found Python 2.7 via command:", python27
            return python27
    exit("BESST needs Python >= 2.7, make sure it is aliased to either the 'python' or the 'python2.7' command on your shell")


def besst(contigs, bam_files, output_filename=""):
    interpreter = check_for_python_27()
    cmd = ['-c', contigs, '-f'] + bam_files + ['--no_score', '--iter',100000, '-filter_contigs', 1000, '-o', prefix + '_besst']
    execute('BESST/runBESST', cmd, interpreter=interpreter, memused=True)
    besst_scaffolds = sorted(glob.glob(prefix + "_besst/BESST_output/pass*/*.fa"))
    if len(besst_scaffolds) == 0:
        exit("Error: BESST returned no results in %s" % (prefix + "_besst/"))
    last_pass = besst_scaffolds[-1]
    final_assembly = prefix + ".besst.scaffolds.fasta"
    if os.path.exists(final_assembly):
        os.remove(final_assembly)
    os.symlink(last_pass, final_assembly)
    print "BESST is done! the maximal memory used above was for BESST only"
    print "final assembly:",final_assembly
    

# ------------------------------
# wrapper for scaffolding

def scaffold(contigs, paired_reads):
    if scaffolding_method == "superscaffolder":
        # superscaf takes one library at a time
        for i, paired_read in enumerate(paired_reads):
            input_file = prefix + ".scaffolds%d.fa" % i if i > 0 else contigs
            output_file = prefix + ".scaffolds%d.fa" % (i+1)
            superscaffolder(input_file,paired_read,output_file)
    elif scaffolding_method == "sspace":
        sspace(contigs,paired_reads)
    elif scaffolding_method == "besst":
        # besst needs pre-mapping one library at a time
        bam_files = []
        for i, paired_read in enumerate(paired_reads):
            bam_files += [run_besst_mapping(i,contigs,paired_read)]
        besst(contigs,bam_files)


# ------------------------------
# main pipeline

def assemble_single_k():
    global k, min_abundance, genome_size, list_reads, contigs, prefix
    if not contigs:
        if not k or not min_abundance:
            genome_size, k, min_abundance = kmergenie(list_reads, one_pass=True)
        contigs = minia(k, min_abundance, prefix=prefix)

create_list_reads()

if not multi_k_mode:
    assemble_single_k()
else:
    # multi-k assembly algorithms following the idea of idba/spades to reconstruct graph with larger k and reinject previous contigs
    kmergenie(list_reads, one_pass=True)
    results = parse_kmergenie_results()
    cutoffs = dict([(k,min_abundance) for (genome_size, k, min_abundance) in results] )
    genome_size = max(results)[0]
    # add cutoff=2 for larger k values for which there was no fit
    # disabled for my tests now
    for k in all_k_values_fitted_or_not():
        if k not in cutoffs:
            cutoffs[k] = 2
    step = 10 # maybe set that as parameter
    last_k_value = 0
    previous_contigs = None
    for k in sorted(cutoffs.keys()):
        if k < last_k_value + step:
            continue
        min_abundance = cutoffs[k]
        print "Multi-k GATB-Pipeline, Minia assembling at k=%d min_abundance=%d genome_size=%d" % (k, min_abundance, genome_size)
        extra_reads = [previous_contigs]*(min_abundance+1) if previous_contigs is not None else []
        create_list_reads(extra_reads)
        multi_k_prefix = prefix + "_k%d" % k
        previous_contigs = minia(k, min_abundance, prefix=multi_k_prefix)
        last_k_value = k 
    print "Finished Multi-k GATB-Pipeline with k=%d" % last_k_value

# scaffolding all libraries
scaffold(contigs, paired_reads)

print "pipeline finished!!"
