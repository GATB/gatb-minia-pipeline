#!/usr/bin/env python

import sys, os
from subprocess import call
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) #unbuffered print, solves badly ordered stdout on clusters

prefix="assembly"

doc = """GATB Pipeline

Usage:
    %s [arguments]

Reads (mandatory, specify at least one of these parameters):
    -p interleaved_paired_reads     interleaved FASTA or FASTQ paired reads
    -p left_mates right_mates       two FASTA or FASTQ paired reads (non-interleaved)
    -u unpaired_reads               unpaired FASTA or FASTQ reads

Optional parameters:
    -c contigs_file                 only perform scaffolding+gapfilling from these contigs
    -k kmer_size                    use this k-mer size (skips kmergenie if both -k and -t are specified)
    -m min_abundance                use this minimum abundance value
""" % (sys.argv[0])

paired_reads = []
unpaired_reads = []
contigs = None
genome_size = 0
k = 0
min_abundance = 0

try:
    for i,arg in enumerate(sys.argv):
        if arg == "-p":
           print "a",arg,sys.argv[i+1]
           if i+2 >= len(sys.argv) or sys.argv[i+2][0] == "-":
               # interleaved case
               paired_reads.append(sys.argv[i+1])
           else:
               # non-interleaved case
               paired_reads.append( sys.argv[i+1] + " " + sys.argv[i+2])
        elif arg == "-u":
           unpaired_reads.append(sys.argv[i+1])
        elif arg == "-c":
           contigs = sys.argv[i+1]
        elif arg == "-k":
           k = int(sys.argv[i+1])
        elif arg == "-m":
           min_abundance = int(sys.argv[i+1])
    if len(paired_reads) + len(unpaired_reads) == 0:
        raise Exception 
except:
    print doc
    sys.exit(1)


DIR = os.path.dirname(os.path.realpath(__file__))

def execute(program, cmdline="", interpreter=""):
    try:
        return call("%s %s/%s %s" % (interpreter, DIR, program, cmdline), shell=True)
    except OSError as e:
        print >>sys.stderr, "Execution of '%s' with command-line '%s' failed:" % (program, cmdline), e

# create of flat text file with all reads
list_reads = prefix + ".list_reads"
with open(list_reads,"w") as f:
    for read in paired_reads + unpaired_reads:
        f.write( "\n".join(read.strip().split()) +"\n")

# ------------------------------
# kmergenie

from kmergenie.wrapper import kmergenie

# ------------------------------
# minia

def minia():
    global contigs
    print "compiling minia to support k=%d" % k

    call("make k=%d -C %s/minia/" % (k, DIR), shell=True)

    print "running minia"

    execute('minia/minia', "%s %d %d %d %s" % (list_reads, k, min_abundance, genome_size, prefix))
    contigs = prefix + ".contigs.fa"

# ------------------------------
# superscaffolder

def superscaffolder(contigs,library,output_filename=""):
    execute("superscaffolder/superscaffolding.py", "%s %s -o %s" % (contigs, library, output_filename), "python")


# ------------------------------
# main pipeline

if not contigs:
    if not k or not min_abundance:
        genome_size, k, min_abundance = kmergenie(list_reads)
    minia()

# scaffolding all libraries
for i, paired_read in enumerate(paired_reads):
    input_file = prefix + ".scaffolds%d.fa" % i if i > 0 else contigs
    output_file = prefix + ".scaffolds%d.fa" % (i+1)
    superscaffolder(input_file,paired_read,output_file)

print "pipeline finished!!"
