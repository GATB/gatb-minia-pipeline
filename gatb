#!/usr/bin/env python

import sys, os
from subprocess import call, Popen, PIPE
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) #unbuffered print, solves badly ordered stdout on clusters

prefix="assembly"

doc = """GATB Pipeline

Usage:
    %s [arguments]

Reads (mandatory, specify at least one of these parameters):
    -p interleaved_paired_reads     interleaved FASTA or FASTQ paired reads
    -p left_mates right_mates       two FASTA or FASTQ paired reads (non-interleaved)
    -u unpaired_reads               unpaired FASTA or FASTQ reads
    -l list_of_unpaired_reads       one file name per line
    -m interleaved_mate_pairs       same input as paired reads (-p) but for mate pairs
    -m left_mates right_mates       same input as paired reads (-p) but for mate pairs

Optional parameters:
    -c contigs_file                 only perform scaffolding+gapfilling from these contigs
    -k kmer_size                    use this k-mer size (skips kmergenie if -k, -t and -g are specified)
    -t min_abundance                use this minimum abundance value
    -g genome_size                  adjust memory usage with respect to this genome size
    --multik                        multi-k mode (experimental, not currently supported)
""" % (sys.argv[0])

paired_reads = []
mate_pairs = []
unpaired_reads = []
contigs = None
genome_size = 0
k = 0
min_abundance = 0
multi_k_mode = False 

try:
    skip = 1 # to handle paired-end case (-p XX XX)
    for i,arg in enumerate(sys.argv):
        if skip > 0:
            skip -= 1
            continue
        skip = 1
        if arg == "-p" or arg == "-m":
           if i+2 >= len(sys.argv) or sys.argv[i+2][0] == "-":
               # interleaved case
               library = sys.argv[i+1]
               has_space = ' ' in sys.argv[i+1]
           else:
               # non-interleaved case
               library = sys.argv[i+1] + " " + sys.argv[i+2]
               skip = 2
               has_space = ' ' in sys.argv[i+1] or ' ' in sys.argv[i+2]
           if has_space:
               print("Space character isn't allowed in file names")
               exit(0)
           paired_reads.append(library)
           if arg == "-m":
               mate_pairs.append(library)
        elif arg == "-u":
           unpaired_reads.append(sys.argv[i+1])
        elif arg == "-c":
           contigs = sys.argv[i+1]
        elif arg == "-k":
           k = int(sys.argv[i+1])
        elif arg == "-t":
           min_abundance = int(sys.argv[i+1])
        elif arg == "-g":
           genome_size = int(sys.argv[i+1])
        elif arg == "--multik":
           multi_k_mode = True
        elif arg == "-l":
            unpaired_reads = open(sys.argv[i+1]).read().splitlines()
        else:
            print("Unknown parameters", arg)
    if len(paired_reads) + len(unpaired_reads) == 0:
        raise Exception("Please input at least one read dataset") 
except:
    import traceback
    traceback.print_exc()
    print doc
    sys.exit(1)

if k != 0 and (min_abundance == 0 or genome_size == 0):
    sys.exit("If you specify k, please specify min_abundance and genome_size as well")


DIR = os.path.dirname(os.path.realpath(__file__))

def execute(program, cmdline=[], interpreter=None, stdout=None):
    try:
        cmd = [interpreter] if interpreter else []
        if program is not None:
            cmd += [ "%s/%s" % (DIR, program) ] 
        cmd += map(str, cmdline)
        return call(cmd, stdout=stdout)
    except OSError as e:
        print >>sys.stderr, "Execution of '%s' with command-line '%s' failed:" % (program, cmdline), e

list_reads = prefix + ".list_reads"

def create_list_reads(extra_reads = []):
    # create of flat text file with all reads
    with open(list_reads,"w") as f:
        for read in paired_reads + unpaired_reads + extra_reads:
            f.write( "\n".join(read.strip().split()) +"\n")

# ------------------------------
# kmergenie

from kmergenie.wrapper import kmergenie
from kmergenie.wrapper import parse_kmergenie_results 
from kmergenie.wrapper import all_k_values_fitted_or_not

# ------------------------------
# minia

def minia(k, min_abundance, prefix):
    global genome_size
    global contigs
    if k == 0:
        exit('cannot run minia with k=0 (did kmergenie fail to detect best k?)')
    print "compiling minia to support k=%d" % k

    call("make -j8 k=%d -C %s/minia/" % (k, DIR), shell=True)

    print "running minia"

    execute('minia/minia', [list_reads, k, min_abundance, genome_size, prefix])
    contigs = prefix + ".contigs.fa"
    return contigs

# ------------------------------
# superscaffolder

def superscaffolder(contigs,library,output_filename=""):
    execute("superscaffolder/superscaffolding.py", [contigs, library, "-o", output_filename], "python")

#-------------------------------
# sspace wrapper

def get_paired_end_parameters(contigs, library, is_mate_pairs = False):
    paired_reads = library.split(' ')
    cmd = ["%s/tools/estimate-insert-sizes" % DIR, contigs] + paired_reads
    if is_mate_pairs:
        cmd += ["--RF"] # force mate pairs
    output = Popen(cmd, stdout=PIPE).communicate()[0]
    orientation, mean, stdev = None, None, None
    for line in output.split('\n'):
        if line.startswith('Orientation'):
            l = line.split()
            orientation, mean, stdev = l[1], int(l[3]), int(l[5])
    print "GATB-Pipeline estimated insert size of library", paired_reads, ":", mean, stdev, orientation
    return orientation, mean, stdev
    
def possibly_gunzip(filename, lib_index, paired_index=None):
    if filename.endswith('.gz'):
        unzipped_filename = '.'.join(filename.split(".")[:-1])
        ext = unzipped_filename.split(".")[-1]
        output = prefix + '.lib%d' % lib_index 
        if paired_index:
            output += "_%d" % paired_index
        output += "." + ext
        print "Gunzipping", filename, "to", output
        outfile = open(output, 'wb')
        execute(None, ['-c', filename], interpreter='gunzip', stdout=outfile)
        outfile.close
        return output 
    return filename

def sspace(contigs, paired_reads, output_filename=""):
    # create a sspace config file
    lib_file = prefix + '.sspace.config'
    with open(lib_file, 'w') as f:
        for i, library in enumerate(paired_reads):
            is_mate_pairs = library in mate_pairs
            # sspace needs de-interleaved input
            if ' ' not in library:
                library = possibly_gunzip(library, i)
                print "Splitting interleaved file:", library
                ext = library.split(".")[-1]
                p1, p2 = [prefix + ".lib%d_%d." % (i,j) + ext for j in [1,2] ]
                #de-interleave reads using SGA's script (was too lazy to write my own)
                execute('tools/sga-deinterleave.pl', [library, p1, p2], interpreter="perl")
                library = p1 + " " + p2
            else:
                # sspace basic cannot work with gzipped files
                p1, p2 = library.split(' ')
                library = possibly_gunzip(p1, i, 1) + ' ' + possibly_gunzip(p2, i, 2)

            # estimate insert size
            orientation, mean, stdev = get_paired_end_parameters(contigs, library, is_mate_pairs)
            if orientation is None:
                exit("Error running estimate-insert-sizes for library: %s" % library)

            # sspace error isn't exactly the stdev; subjectively, I'm converting using 3 sigmas
            error = min(max(0.1, stdev * 3.0 / mean),0.9)
            f.write('lib%d %s %d %0.1f %s\n' % (i, library, mean, error, orientation))

    # run sspace
    cmd = ['-l', lib_file, '-s', contigs, '-b', prefix + '.sspace']
    execute('sspace/SSPACE_Basic_v2.0.pl', cmd, interpreter="perl")

    # clean up intermediate sspace files
    

# ------------------------------
# wrapper for scaffolding

#method="superscaffolder"
method="sspace"
def scaffold(contigs, paired_reads):
    if method == "superscaffolder":
        # superscaf takes one library at a time
        for i, paired_read in enumerate(paired_reads):
            input_file = prefix + ".scaffolds%d.fa" % i if i > 0 else contigs
            output_file = prefix + ".scaffolds%d.fa" % (i+1)
            superscaffolder(input_file,paired_read,output_file)
    elif method == "sspace":
        sspace(contigs,paired_reads)


# ------------------------------
# main pipeline

def assemble_single_k():
    global k, min_abundance, genome_size, list_reads, contigs, prefix
    if not contigs:
        if not k or not min_abundance:
            genome_size, k, min_abundance = kmergenie(list_reads, one_pass=True)
            genome_size = max(1000000000, genome_size) #hack to make it use at least 1GB of memory to go faster on bacterial genomes
        contigs = minia(k, min_abundance, prefix=prefix)

create_list_reads()

if not multi_k_mode:
    assemble_single_k()
else:
    # multi-k assembly algorithms following the idea of idba/spades to reconstruct graph with larger k and reinject previous contigs
    kmergenie(list_reads, one_pass=True)
    results = parse_kmergenie_results()
    cutoffs = dict([(k,min_abundance) for (genome_size, k, min_abundance) in results] )
    genome_size = max(1000000000,max(results)[0]) #hack to make it use at least 1GB of memory to go faster on bacterial genomes
    # add cutoff=2 for larger k values for which there was no fit
    # disabled for my tests now
    for k in all_k_values_fitted_or_not():
        if k not in cutoffs:
            cutoffs[k] = 2
    step = 10 # maybe set that as parameter
    last_k_value = 0
    previous_contigs = None
    for k in sorted(cutoffs.keys()):
        if k < last_k_value + step:
            continue
        min_abundance = cutoffs[k]
        print "Multi-k GATB-Pipeline, Minia assembling at k=%d min_abundance=%d genome_size=%d" % (k, min_abundance, genome_size)
        extra_reads = [previous_contigs]*(min_abundance+1) if previous_contigs is not None else []
        create_list_reads(extra_reads)
        multi_k_prefix = prefix + "_k%d" % k
        previous_contigs = minia(k, min_abundance, prefix=multi_k_prefix)
        last_k_value = k 
    print "Finished Multi-k GATB-Pipeline with k=%d" % last_k_value

# scaffolding all libraries
scaffold(contigs, paired_reads)

print "pipeline finished!!"
